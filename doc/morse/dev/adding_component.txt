>> [[morse:dev:summary | Developer's documentation]]

====== Adding a new component ======

There are two things to do when you want to add a sensor / an actuator :
  * a blender part : creating a representation of the sensor on blender, and associate the script with the blender object
  * the python script which contains the logic of the sensor

=== The python part ===

You need to implement a sub-class of morse.helpers.sensor.MorseSensorClass (respectively of morse.helpers.actuator.MorseActuatorClass)

Important things to do :
  * in the constructor of the object (**__init__**) :
	* initialize each variable you want to expose to the world into local_data
	* initialize correctly data_keys with the set of variable exposed in
	  local_data : the order is important here, because this order will be used
	  for the automatic serialization
	* initialize correctly modified_data, with a copy of local_data (the
	  easiest way is to copy-paste the following code)
	<code python>
		for variable in self.data_keys:
			self.modified_data.append(self.local_data[variable])
	</code>

  * override default_action : it must contains the logic of our component.
    Avoid to do some big computation here : the function is called often, and
    it will be slow the whole processing of the Game Engine

=== The blender part ===

  - First, create a nice modelling of your object, and save it in $ORS_ROOT/data/morse/components/sensors/
  - Press <key>N</key> to display the properties of the object. Change its name.
  - Press <key>F4</key> to enter in the logic mode
    - Add the two following properties :
	  * class of type string, which contains the name of the associated python class <Sensor>Class
	  * path of type string, which contains the path of the associated python script morse/sensors/<Sensor	  - You can add more properties if needed for your components
	- TODO **finish to explain how to link script to blender object**

=== Getting data or exporting data ===

A component is not really useful if it doesn't get any input (for an actuator)
or if you can't use the output of sensor. You can use different middleware to
import / export data. 

Basically, you can use automatic serialization. If you want more specific
behaviour, you need to add a method to the middleware provider of your choice
(for example, if you want to export a new sensor through YARP, you need to add
a method to MorseYarpClass, in $ORS_ROOT/src/morse/middleware/yarp_mw.py). The
method must have the following prototype :

<code python>
def your_method(self, component_instance)
</code>

In this method, you can access / store component information through its array
**modified_data**. In case of a sensor, it is not expected that you change the
content of the sensor, but only read information in this array.

After that, you need to register your new function into the middleware
abstraction.  For that, you need to modify the method **register_component**.
It is basically a switch case with the different possible function. It is this
function which is called when parsing the configuration file for the scene, so
it is the right place to initialize stuff (top open Yarp ports, socket, file
...)

== Middleware specific information ==

= YARP =

In MorseYarpClass, the different port_name are stored in a dictionary
**_component_ports**, indexed by the name of the component
(**component.blender_obj.name**). You can retrieve the associated port with the method
**getPort( port_name)**

= Pocolibs =

In MorsePocolibsClass, the different poster_id are stored in a dictionary
**_poster_dict**, indexed by the name of the component
(**component.blender_obj.name**)

= Text =

In TextOutClass, the different files are stored in a dictionary
**_file_list**, indexed by the name of the component
(**component.blender_obj.name**)
